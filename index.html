<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Surf Forecast</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Roboto', sans-serif; background: #eef2f5; color: #333; }
    header { background: #1e3a8a; color: #fff; padding: 1rem; text-align: center; }
    .container { max-width: 1200px; margin: 2rem auto; padding: 0 1rem; }
    .search { margin-bottom: 1.5rem; display: flex; justify-content: center; }
    .search input { width: 300px; padding: 0.5rem 1rem; border: 1px solid #ccc; border-radius: 4px 0 0 4px; }
    .search button { padding: 0.5rem 1rem; border: none; background: #2563eb; color: white; border-radius: 0 4px 4px 0; cursor: pointer; }
    .day-list { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 1rem; }
    .day-card { background: #fff; border-radius: 8px; padding: 1rem; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: flex; flex-direction: column; justify-content: space-between; }
    .rating { font-size: 1.2rem; font-weight: 500; }
    .rating.gray { color: #6b7280; }
    .rating.yellow { color: #facc15; }
    .rating.green { color: #22c55e; }
    .rating.blue { color: #60a5fa; }
    .rating.purple { color: #a78bfa; }
    .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; }
    .modal-content { background: #fff; border-radius: 8px; width: 90%; max-width: 800px; max-height: 90vh; overflow-y: auto; padding: 1.5rem; position: relative; }
    .close { position: absolute; top: 1rem; right: 1rem; background: none; border: none; font-size: 1.5rem; cursor: pointer; }
    .compass-container { position: relative; width: 100%; height: 300px; }
    #compass { width: 100%; height: 100%; }
    .slider { width: 100%; margin-top: 1rem; }
    .key { display: flex; gap: 1rem; margin-top: 1rem; }
    .key-item { display: flex; align-items: center; gap: 0.5rem; }
    .arrow-sample { width: 20px; height: 20px; }
    footer { text-align: center; margin: 2rem 0; font-size: 0.9rem; color: #555; }
  </style>
</head>
<body>
  <header><h1>Surf Forecast</h1></header>
  <div class="container">
    <div class="search">
      <input id="locationInput" placeholder="City or ZIP (e.g. Ocean City, NJ)" />
      <button id="searchBtn">Get Forecast</button>
    </div>
    <div id="dayList" class="day-list"></div>
    <footer id="lastUpdated">Last updated: --</footer>
  </div>

  <div id="detailModal" class="modal" aria-hidden="true" role="dialog" aria-labelledby="detailDate">
    <div class="modal-content">
      <button class="close" aria-label="Close modal">&times;</button>
      <h2 id="detailDate"></h2>
      <div id="detailStats"></div>
      <div class="compass-container"><canvas id="compass"></canvas></div>
      <input type="range" id="hourSlider" class="slider" min="0" max="23" value="0" aria-label="Select hour" />
      <div class="key">
        <div class="key-item"><canvas class="arrow-sample" id="swellKey"></canvas><span>Swell</span></div>
        <div class="key-item"><canvas class="arrow-sample" id="windKey"></canvas><span>Wind</span></div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    async function geocode(place) {
      const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(place)}`);
      const data = await res.json();
      if (!data || data.length === 0) throw new Error('Location not found');
      return { lat: data[0].lat, lon: data[0].lon };
    }

    async function fetchNWS(lat, lon) {
      const pts = await fetch(`https://api.weather.gov/points/${lat},${lon}`).then(r => r.json());
      if (!pts.properties) throw new Error('NWS Point lookup failed');
      const forecastUrl = pts.properties.forecast;
      const forecastHourlyUrl = pts.properties.forecastHourly;
      if (!forecastUrl || !forecastHourlyUrl) throw new Error('Forecast URLs missing');
      const daily = await fetch(forecastUrl).then(r => r.json()).then(j => j.properties.periods);
      const hourly = await fetch(forecastHourlyUrl).then(r => r.json()).then(j => j.properties.periods);
      return { daily, hourly };
    }

    async function fetchTides(stationId, beginDate, endDate) {
      const url = `https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?product=predictions&application=web&begin_date=${beginDate}&end_date=${endDate}&station=${stationId}&time_zone=lst_ldt&units=english&interval=hilo&format=json`;
      const res = await fetch(url);
      if (!res.ok) throw new Error('Failed to fetch tides');
      const data = await res.json();
      return data.predictions || [];
    }

    function getRating({ swell, windSpeed, period }) {
      const score = (swell || 0) * (period || 1) / 10 - (windSpeed || 0) / 10;
      if (score < 3) return { label: 'Flat', color: 'gray' };
      if (score < 6) return { label: 'Okay', color: 'yellow' };
      if (score < 9) return { label: 'Good', color: 'green' };
      if (score < 12) return { label: 'Great', color: 'blue' };
      return { label: 'Epic', color: 'purple' };
    }

    function datePart(datetime) {
      return datetime.split('T')[0];
    }

    function ratingScore(label) {
      switch (label) {
        case 'Flat': return 0;
        case 'Okay': return 1;
        case 'Good': return 2;
        case 'Great': return 3;
        case 'Epic': return 4;
        default: return 0;
      }
    }

    const stationOceanCity = '8570282'; // Ocean City Fishing Pier NOAA station

    function drawArrow(ctx, color, lineWidth, arrowSize) {
      ctx.clearRect(0, 0, 20, 20);
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.beginPath();
      ctx.moveTo(10, 18);
      ctx.lineTo(10, 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(10, 2);
      ctx.lineTo(10 - arrowSize / 2, 2 + arrowSize);
      ctx.lineTo(10 + arrowSize / 2, 2 + arrowSize);
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
    }

    let compassChart = null;
    const compassCtx = document.getElementById('compass').getContext('2d');

    function updateCompass(hour) {
      if (compassChart) {
        compassChart.destroy();
        compassChart = null;
      }

      const labels = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];

      // swell direction estimate: approximate from wind direction for demo (NWS doesn't provide swell dir)
      const swellDir = hour.windDirection?.value ?? 0;
      const windDir = hour.windDirection?.value ?? 0;

      // swell height from shortForecast, fallback 0
      let swellHeight = 0;
      const swellMatch = hour.shortForecast?.match(/(\d+)-?(\d*) ft/);
      if (swellMatch) swellHeight = parseFloat(swellMatch[1]);

      const windSpeed = hour.windSpeed?.value ?? 0;

      function dirToIndex(deg) {
        return Math.round(deg / 45) % 8;
      }

      const swellData = new Array(8).fill(0);
      const windData = new Array(8).fill(0);
      swellData[dirToIndex(swellDir)] = swellHeight;
      windData[dirToIndex(windDir)] = windSpeed / 5;

      compassChart = new Chart(compassCtx, {
        type: 'polarArea',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Swell',
              data: swellData,
              backgroundColor: 'rgba(51, 51, 51, 0.7)'
            },
            {
              label: 'Wind',
              data: windData,
              backgroundColor: 'rgba(170, 170, 170, 0.7)'
            }
          ]
        },
        options: {
          plugins: { legend: { display: true } },
          scales: { r: { beginAtZero: true } }
        }
      });
    }

    function showDetail(day, hours, tideDay) {
      const modal = document.getElementById('detailModal');
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
      document.getElementById('detailDate').textContent = day.name;

      const tideHigh = tideDay.find(t => t.type === 'H');
      const tideLow = tideDay.find(t => t.type === 'L');
      const statsDiv = document.getElementById('detailStats');
      statsDiv.innerHTML = `
        <p>${day.shortForecast}</p>
        <p>Tide High: ${tideHigh ? tideHigh.v : 'N/A'} ft, Tide Low: ${tideLow ? tideLow.v : 'N/A'} ft</p>
      `;

      const slider = document.getElementById('hourSlider');
      slider.max = hours.length - 1;
      slider.value = 0;
      slider.oninput = () => updateCompass(hours[slider.value]);

      updateCompass(hours[0]);

      drawArrow(document.getElementById('swellKey').getContext('2d'), '#333', 3, 8);
      drawArrow(document.getElementById('windKey').getContext('2d'), '#aaa', 2, 6);
    }

    function ratingFromHour(hour) {
      // parse swell from shortForecast string
      let swell = 0;
      const match = hour.shortForecast?.match(/(\d+)-?(\d*) ft/);
      if (match) swell = parseFloat(match[1]);
      const windSpeed = hour.windSpeed?.value ?? 0;
      const period = 10; // default period
      return getRating({ swell, windSpeed, period });
    }

    function renderDays(daily, hourly, tides) {
      const dayList = document.getElementById('dayList');
      dayList.innerHTML = '';

      // Group tides by date
      const tidesByDate = {};
      tides.forEach(t => {
        const dt = t.t.split(' ')[0];
        if (!tidesByDate[dt]) tidesByDate[dt] = [];
        tidesByDate[dt].push(t);
      });

      // Group hourly by date
      const hourlyByDate = {};
      hourly.forEach(h => {
        const d = datePart(h.startTime);
        if (!hourlyByDate[d]) hourlyByDate[d] = [];
        hourlyByDate[d].push(h);
      });

      daily.slice(0, 10).forEach(day => {
        const dateKey = datePart(day.startTime);
        const hours = hourlyByDate[dateKey] || [];
        if (hours.length === 0) return;

        // Find best hour by rating score
        let bestHour = hours[0];
        let bestRating = ratingFromHour(bestHour);

        for (const h of hours) {
          const r = ratingFromHour(h);
          if (ratingScore(r.label) > ratingScore(bestRating.label)) {
            bestRating = r;
            bestHour = h;
          }
        }

        const tideDay = tidesByDate[dateKey] || [];
        const tideHigh = tideDay.find(t => t.type === 'H');
        const tideLow = tideDay.find(t => t.type === 'L');

        const card = document.createElement('div');
        card.className = 'day-card';
        card.innerHTML = `
          <div><strong>${day.name}</strong></div>
          <div class="rating ${bestRating.color}">${bestRating.label} @ ${new Date(bestHour.startTime).getHours()}:00</div>
          <div>Tide H: ${tideHigh ? tideHigh.v : 'N/A'} ft / L: ${tideLow ? tideLow.v : 'N/A'} ft</div>
          <div>Swell Est: ${bestHour.shortForecast?.match(/(\\d+)-?(\\d*) ft/) ? bestHour.shortForecast.match(/(\\d+)-?(\\d*) ft/)[0] : 'N/A'}</div>
        `;

        card.onclick = () => showDetail(day, hours, tideDay);
        dayList.appendChild(card);
      });

      document.getElementById('lastUpdated').textContent = 'Last updated: ' + new Date().toLocaleString();
    }

    document.querySelector('.close').addEventListener('click', () => {
      const modal = document.getElementById('detailModal');
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
    });

    document.getElementById('searchBtn').addEventListener('click', async () => {
      const locationInput = document.getElementById('locationInput');
      const place = locationInput.value.trim();
      if (!place) {
        alert('Please enter a location.');
        return;
      }

      try {
        const { lat, lon } = await geocode(place);
        const nwsData = await fetchNWS(lat, lon);

        const today = new Date();
        const beginDate = today.toISOString().slice(0, 10).replace(/-/g, '');
        const endDateObj = new Date(today.getTime() + 9 * 24 * 3600 * 1000);
        const endDate = endDateObj.toISOString().slice(0, 10).replace(/-/g, '');

        // Using Ocean City station as default for tides; for a real app you'd want to find nearest station by lat/lon
        const tidesData = await fetchTides(stationOceanCity, beginDate, endDate);

        renderDays(nwsData.daily, nwsData.hourly, tidesData);
      } catch (err) {
        alert('Error fetching forecast: ' + err.message);
      }
    });

    // Optional: pre-fill Ocean City and auto load on page load
    window.addEventListener('load', () => {
      document.getElementById('locationInput').value = 'Ocean City, NJ';
      document.getElementById('searchBtn').click();
    });
  </script>
</body>
</html>
